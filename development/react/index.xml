<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>React on</title><link>https://kkoscielniak.github.io/the-garden/development/react/</link><description>Recent content in React on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://kkoscielniak.github.io/the-garden/development/react/index.xml" rel="self" type="application/rss+xml"/><item><title>`children` prop</title><link>https://kkoscielniak.github.io/the-garden/development/react/children-prop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/children-prop/</guid><description>The usual way of using children:
1 2 3 &amp;lt;Header&amp;gt; &amp;lt;ChildComponent truthy /&amp;gt; &amp;lt;/Header&amp;gt; is a syntax sugar for:</description></item><item><title>Component state vs Class fields</title><link>https://kkoscielniak.github.io/the-garden/development/react/component-state-vs-class-fields/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/component-state-vs-class-fields/</guid><description>Changing the state of the component causes UI to re-render. Thus, keeping UI-agnostic data as class fields is okay.
It&amp;rsquo;s important not to re-render UI if it is not necessary, as this impacts the performance.</description></item><item><title>Containers vs Presentation Components</title><link>https://kkoscielniak.github.io/the-garden/development/react/containers-vs-presentation-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/containers-vs-presentation-components/</guid><description>a.k.a. smart and dumb components.
The idea is to split the component into 2 smaller ones:
the smart component (a Container or Manager) manages the state of the component provides data for the dumb component to render the dumb component (a Presentational one) responsible only for rendering the data This also makes the presentational components reusable.</description></item><item><title>Higher Order Components</title><link>https://kkoscielniak.github.io/the-garden/development/react/HOCs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/HOCs/</guid><description>Higher Order Components is a [[pattern]] in [[development/react/_index|React]] allowing to enhance the component with additional logic (like authentication, state).
A HOC in that regard is a component that wraps the enhanced one:</description></item><item><title>key prop</title><link>https://kkoscielniak.github.io/the-garden/development/react/key/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/key/</guid><description>The key prop is a necessary prop whenever we&amp;rsquo;re rendering the components dynamically (e.g. using .map), as it is a basis for React to know how to match data with the components properly.</description></item><item><title>moize</title><link>https://kkoscielniak.github.io/the-garden/development/react/moize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/moize/</guid><description>[[development/react/useMemo]] has its limits - for example if we&amp;rsquo;re [[memoization|memoizing]] the same results but in different components:
1 2 3 4 const n = 1; // .</description></item><item><title>Profiling tools</title><link>https://kkoscielniak.github.io/the-garden/development/react/profiling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/profiling/</guid><description>/* [...] */
It makes no sense to profile the development version of the app.
To profile the production version of the app we need to first run:</description></item><item><title>Prop drilling</title><link>https://kkoscielniak.github.io/the-garden/development/react/prop-drilling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/prop-drilling/</guid><description>Prop drilling (a.k.a. threading) is the process of passing data from one component to multiple independent, usually nested children until the data reaches the component that uses it.</description></item><item><title>Pure Component</title><link>https://kkoscielniak.github.io/the-garden/development/react/pure-component/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/pure-component/</guid><description>A Pure Component is a component that doesn&amp;rsquo;t rerender unless its props or state changes.
Explaination In ordinary components we have shouldComponentUpdate(nextProps, nextState) method (that returns true by default).</description></item><item><title>React Window</title><link>https://kkoscielniak.github.io/the-garden/development/react/react-window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/react-window/</guid><description>react-window is a library used for optimizing rendering of lists with many records with virtualization of the list.
Virtualised lists may prevent âŒ˜+F to work properly, as the invisible elements are - in fact - removed from the DOM tree.</description></item><item><title>React.memo</title><link>https://kkoscielniak.github.io/the-garden/development/react/react-memo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/react-memo/</guid><description>With React.Memo, we can make the functional component to behave like a class [[development/react/pure-component]].
We create new constant that&amp;rsquo;d keeps the result of React.</description></item><item><title>Reconciliation</title><link>https://kkoscielniak.github.io/the-garden/development/react/reconciliation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/reconciliation/</guid><description>Reconciliation is the algorithm used by [[development/react/_index|React]] every time it has to rerender the application.
Initially, when we define the application structure (first render), React goes through the components and builds a tree of them.</description></item><item><title>Render props</title><link>https://kkoscielniak.github.io/the-garden/development/react/render-props/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/render-props/</guid><description>Render props is a [[pattern]] in [[development/react/_index|React]].
The idea is to pass a function rendering the [[development/react/containers-vs-presentation-components|presentational component]] as a child prop, so the parent is responsible for maintaining the rendering logic.</description></item><item><title>useCallback</title><link>https://kkoscielniak.github.io/the-garden/development/react/useCallback/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/useCallback/</guid><description>Each time we rerender the component, the callback functions are recreated.
The useCallback hook is used to make functions recreate only if the dependencies change (similarly to [[useEffect]] and [[development/react/useMemo]]).</description></item><item><title>useMemo</title><link>https://kkoscielniak.github.io/the-garden/development/react/useMemo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kkoscielniak.github.io/the-garden/development/react/useMemo/</guid><description>useMemo is a hook allowing to save the returned value of time-consuming, costful function between subsequent rerenders.
This process is called [[memoization]].</description></item></channel></rss>